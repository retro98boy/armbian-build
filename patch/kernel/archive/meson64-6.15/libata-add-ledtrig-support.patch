From 0924679ec3068dd96056184770770d612c344133 Mon Sep 17 00:00:00 2001
From: Daniel Golle <daniel@makrotopia.org>
Date: Sun, 10 Aug 2025 22:24:25 +0800
Subject: [PATCH] libata: add ledtrig support

---
 drivers/ata/Kconfig       | 12 ++++++++++++
 drivers/ata/libata-core.c | 39 +++++++++++++++++++++++++++++++++++++++
 include/linux/libata.h    |  7 +++++++
 3 files changed, 58 insertions(+)

diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index e00536b49..87d79bd6a 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -67,6 +67,18 @@ config ATA_FORCE
 
 	  If unsure, say Y.
 
+config ATA_LEDS
+	bool "support ATA port LED triggers"
+	select NEW_LEDS
+	select LEDS_CLASS
+	select LEDS_TRIGGERS
+	default y
+	help
+	  This option adds a LED trigger for each registered ATA port.
+	  It is used to drive disk activity leds connected via GPIO.
+
+	  If unsure, say N.
+
 config ATA_ACPI
 	bool "ATA ACPI Support"
 	depends on ACPI
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index 773799cfd..717f2a7f8 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -703,6 +703,17 @@ static inline void ata_set_tf_cdl(struct ata_queued_cmd *qc, int cdl)
 	qc->flags |= ATA_QCFLAG_HAS_CDL | ATA_QCFLAG_RESULT_TF;
 }
 
+#ifdef CONFIG_ATA_LEDS
+#define LIBATA_BLINK_DELAY 20 /* ms */
+static inline void ata_led_act(struct ata_port *ap)
+{
+	if (unlikely(!ap->ledtrig))
+		return;
+
+	led_trigger_blink_oneshot(ap->ledtrig, LIBATA_BLINK_DELAY, LIBATA_BLINK_DELAY, 0);
+}
+#endif
+
 /**
  *	ata_build_rw_tf - Build ATA taskfile for given read/write request
  *	@qc: Metadata associated with the taskfile to build
@@ -4767,6 +4778,9 @@ void __ata_qc_complete(struct ata_queued_cmd *qc)
 		link->active_tag = ATA_TAG_POISON;
 		ap->nr_active_links--;
 	}
+#ifdef CONFIG_ATA_LEDS
+	ata_led_act(ap);
+#endif
 
 	/* clear exclusive status */
 	if (unlikely(qc->flags & ATA_QCFLAG_CLEAR_EXCL &&
@@ -5488,6 +5502,9 @@ struct ata_port *ata_port_alloc(struct ata_host *host)
 #ifdef ATA_IRQ_TRAP
 	ap->stats.unhandled_irq = 1;
 	ap->stats.idle_irq = 1;
+#endif
+#ifdef CONFIG_ATA_LEDS
+	ap->ledtrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
 #endif
 	ata_sff_port_init(ap);
 
@@ -5505,6 +5522,12 @@ void ata_port_free(struct ata_port *ap)
 	kfree(ap->pmp_link);
 	kfree(ap->slave_link);
 	ida_free(&ata_ida, ap->print_id);
+#ifdef CONFIG_ATA_LEDS
+	if (ap->ledtrig) {
+		led_trigger_unregister(ap->ledtrig);
+		kfree(ap->ledtrig);
+	};
+#endif
 	kfree(ap);
 }
 EXPORT_SYMBOL_GPL(ata_port_free);
@@ -5909,7 +5932,23 @@ int ata_host_register(struct ata_host *host, const struct scsi_host_template *sh
 		WARN_ON(1);
 		return -EINVAL;
 	}
+#ifdef CONFIG_ATA_LEDS
+	for (i = 0; i < host->n_ports; i++) {
+		if (unlikely(!host->ports[i]->ledtrig))
+			continue;
+
+		snprintf(host->ports[i]->ledtrig_name,
+			sizeof(host->ports[i]->ledtrig_name), "ata%u",
+			host->ports[i]->print_id);
 
+		host->ports[i]->ledtrig->name = host->ports[i]->ledtrig_name;
+
+		if (led_trigger_register(host->ports[i]->ledtrig)) {
+			kfree(host->ports[i]->ledtrig);
+			host->ports[i]->ledtrig = NULL;
+		}
+	}
+#endif
 	/* Create associated sysfs transport objects  */
 	for (i = 0; i < host->n_ports; i++) {
 		rc = ata_tport_add(host->dev,host->ports[i]);
diff --git a/include/linux/libata.h b/include/linux/libata.h
index e5695998a..bae1ec6f0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -23,6 +23,9 @@
 #include <linux/cdrom.h>
 #include <linux/sched.h>
 #include <linux/async.h>
+#ifdef CONFIG_ATA_LEDS
+#include <linux/leds.h>
+#endif
 
 /*
  * Define if arch has non-standard setup.  This is a _PCI_ standard
@@ -932,6 +935,10 @@ struct ata_port {
 #ifdef CONFIG_ATA_ACPI
 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
 #endif
+#ifdef CONFIG_ATA_LEDS
+	struct led_trigger	*ledtrig;
+	char			ledtrig_name[8];
+#endif
 };
 
 /* The following initializer overrides a method to NULL whether one of
-- 
2.50.1

